// Generated by CoffeeScript 1.4.0
/*
#Copyright (c) 2002-2013
#   Jason Siefken
#
#js-continuedfraction is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.
#
#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
# Continued fraction library for javascript
*/

var ContinuedFraction, ExclusiveTimer, MathFunctions, TextAreaChangeTracker, evaluateMath, mathjs, updateFraction,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

ContinuedFraction = (function() {

  ContinuedFraction.prototype.MAX_CONTINUANT = 100000;

  function ContinuedFraction(val) {
    this.continuants = [];
    this.convergents = [];
    if (val instanceof Array) {
      this.continuants = val.slice();
    } else {
      this.continuants = this.continuantsFromNum(val);
    }
    this.computeConvergents();
    this.value = this.computeValue();
  }

  ContinuedFraction.prototype.continuantsFromNum = function(num) {
    var i, ret, _i;
    ret = [];
    if (num >= 1) {
      ret.push(Math.floor(num));
      num -= Math.floor(num);
    } else {
      ret.push(0);
    }
    for (i = _i = 1; _i <= 30; i = ++_i) {
      i = Math.floor(1 / num);
      if (i > this.MAX_CONTINUANT) {
        break;
      }
      ret.push(i);
      num = 1 / num - i;
    }
    if (ret[ret.length - 1] === 1 && ret.length > 1) {
      ret[ret.length - 2] += 1;
      ret.length = ret.length - 1;
    }
    return ret;
  };

  ContinuedFraction.prototype.computeConvergents = function(n) {
    var i, p, pp, q, qq, tmpp, tmpq, _i, _ref;
    p = 1;
    q = 0;
    pp = 0;
    qq = 1;
    for (i = _i = 0, _ref = this.continuants.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      tmpp = p;
      tmpq = q;
      p = this.continuants[i] * p + pp;
      q = this.continuants[i] * q + qq;
      pp = tmpp;
      qq = tmpq;
      this.convergents.push([p, q]);
    }
  };

  ContinuedFraction.prototype.computeValue = function() {
    var approx;
    approx = this.convergents[this.convergents.length - 1];
    return approx[0] / approx[1];
  };

  ContinuedFraction.prototype.toLatex = function(maxLevels) {
    var toLatex;
    if (maxLevels == null) {
      maxLevels = Infinity;
    }
    toLatex = function(coeff) {
      var ret;
      if (coeff.length === 0) {
        return "";
      }
      if (coeff.length === 1) {
        return "" + coeff[0];
      }
      ret = "";
      if (coeff[0] !== 0) {
        ret += "" + coeff[0] + " + ";
      }
      ret += "\\cfrac{1}{";
      ret += toLatex(coeff.slice(1));
      ret += "}";
      return ret;
    };
    return toLatex(this.continuants.slice(0, maxLevels));
  };

  return ContinuedFraction;

})();

/*
# UI code
*/


$(document).ready(function() {
  var continuedfractionTracker, decimalTracker, timer;
  timer = new ExclusiveTimer;
  decimalTracker = new TextAreaChangeTracker('#decimal');
  continuedfractionTracker = new TextAreaChangeTracker('#continuedfraction');
  decimalTracker.change(function() {
    return timer.setTimeout(updateFraction, 250, 'decimal');
  });
  return continuedfractionTracker.change(function() {
    return timer.setTimeout(updateFraction, 250, 'continuedfraction');
  });
});

updateFraction = function(inputType) {
  var a, b, frac, i, table, v, _i, _len, _ref, _ref1;
  switch (inputType) {
    case 'decimal':
      frac = evaluateMath($('#decimal').val());
      frac = new ContinuedFraction(frac);
      $('#continuedfraction').val(frac.continuants);
      break;
    case 'continuedfraction':
      frac = evaluateMath($('#continuedfraction').val());
      frac = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = frac.length; _i < _len; _i++) {
          v = frac[_i];
          if (v != null) {
            _results.push(v);
          }
        }
        return _results;
      })();
      frac = new ContinuedFraction(frac);
      $('#decimal').val(frac.value);
  }
  table = $("<table></table>");
  _ref = frac.convergents.slice(0, 20);
  for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
    _ref1 = _ref[i], a = _ref1[0], b = _ref1[1];
    table.append("<tr>\n    <td>$\\displaystyle\\frac{p_{" + i + "}}{q_{" + i + "}} = \n    \\displaystyle\\frac{" + a + "}{" + b + "}$\n    <span class=\"approx\">$\\approx " + (a / b) + "$</span>\n    </td>\n</tr>");
  }
  $('#convergents .content').html(table);
  $('#prettyprinted .content').html("\\[" + (frac.toLatex(10)) + "\\]");
  return MathJax.Hub.Queue(["Typeset", MathJax.Hub, $('#continuants .content')[0]]);
};

/*
# ExclusiveTimer keeps a queue of all timeout
# callbacks, but only issues the most recent one.
# That is, if another callback request is added before the
# timer on the previous one runs out, only the new one is executed
# (when it's time has elapased) and the previous one is ignored.
*/


ExclusiveTimer = (function() {

  function ExclusiveTimer() {
    this.queue = [];
  }

  ExclusiveTimer.prototype.setTimeout = function(callback, delay, args) {
    var c, doCallback, myIndex, _i, _len, _ref,
      _this = this;
    if (args == null) {
      args = [];
    }
    if (!(args instanceof Array)) {
      args = [args];
    }
    _ref = this.queue;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      c.execute = false;
    }
    myIndex = this.queue.length;
    this.queue.push({
      callback: callback,
      execute: true
    });
    doCallback = function() {
      var _ref1;
      if ((_ref1 = _this.queue[myIndex]) != null ? _ref1.execute : void 0) {
        _this.queue[myIndex].callback.apply(null, args);
        return _this.queue.length = 0;
      }
    };
    return window.setTimeout(doCallback, delay);
  };

  return ExclusiveTimer;

})();

/*
# Keep track of all changes to a particular textarea
# including ones that may happen on keyup, keydown, blur,
# etc.
*/


TextAreaChangeTracker = (function() {

  function TextAreaChangeTracker(textarea) {
    var _this = this;
    this.textarea = textarea;
    this._triggerIfChanged = __bind(this._triggerIfChanged, this);

    this.textarea = $(this.textarea);
    this.value = this.textarea.val();
    this.onchangeCallbacks = [];
    this.textarea.change(function() {
      return window.setTimeout(_this._triggerIfChanged, 100);
    });
    this.textarea.keydown(function() {
      return window.setTimeout(_this._triggerIfChanged, 100);
    });
    this.textarea.keypress(function() {
      return window.setTimeout(_this._triggerIfChanged, 100);
    });
    this.textarea.blur(function() {
      return window.setTimeout(_this._triggerIfChanged, 100);
    });
  }

  TextAreaChangeTracker.prototype._triggerIfChanged = function() {
    var c, newVal, _i, _len, _ref, _results;
    newVal = this.textarea[0].value;
    if (newVal !== this.value) {
      this.value = newVal;
      _ref = this.onchangeCallbacks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(c());
      }
      return _results;
    }
  };

  TextAreaChangeTracker.prototype.change = function(callback) {
    return this.onchangeCallbacks.push(callback);
  };

  return TextAreaChangeTracker;

})();

/*
# All the useful math functions
# Taken from graphit: https://github.com/siefkenj/graphit
*/


MathFunctions = {
  random: Math.random,
  tan: Math.tan,
  min: Math.min,
  PI: Math.PI,
  sqrt: Math.sqrt,
  E: Math.E,
  SQRT1_2: Math.SQRT1_2,
  ceil: Math.ceil,
  atan2: Math.atan2,
  cos: Math.cos,
  LN2: Math.LN2,
  LOG10E: Math.LOG10E,
  exp: Math.exp,
  round: function(n, places) {
    var shift;
    shift = Math.pow(10, places);
    return Math.round(n * shift) / shift;
  },
  atan: Math.atan,
  max: Math.max,
  pow: Math.pow,
  LOG2E: Math.LOG2E,
  log: Math.log,
  LN10: Math.LN10,
  floor: Math.floor,
  SQRT2: Math.SQRT2,
  asin: Math.asin,
  acos: Math.acos,
  sin: Math.sin,
  abs: Math.abs,
  cpi: "\u03C0",
  ctheta: "\u03B8",
  pi: Math.PI,
  phi: (1 + Math.sqrt(5)) / 2,
  ln: Math.log,
  e: Math.E,
  sign: function(x) {
    if (x === 0) {
      return 0;
    } else {
      if (x < 0) {
        return -1;
      } else {
        return 1;
      }
    }
  },
  arcsin: Math.asin,
  arccos: Math.acos,
  arctan: Math.atan,
  sinh: function(x) {
    return (Math.exp(x) - Math.exp(-x)) / 2;
  },
  cosh: function(x) {
    return (Math.exp(x) + Math.exp(-x)) / 2;
  },
  tanh: function(x) {
    return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
  },
  arcsinh: function(x) {
    return ln(x + Math.sqrt(x * x + 1));
  },
  arccosh: function(x) {
    return ln(x + Math.sqrt(x * x - 1));
  },
  arctanh: function(x) {
    return ln((1 + x) / (1 - x)) / 2;
  },
  sech: function(x) {
    return 1 / cosh(x);
  },
  csch: function(x) {
    return 1 / sinh(x);
  },
  coth: function(x) {
    return 1 / tanh(x);
  },
  arcsech: function(x) {
    return arccosh(1 / x);
  },
  arccsch: function(x) {
    return arcsinh(1 / x);
  },
  arccoth: function(x) {
    return arctanh(1 / x);
  },
  sec: function(x) {
    return 1 / Math.cos(x);
  },
  csc: function(x) {
    return 1 / Math.sin(x);
  },
  cot: function(x) {
    return 1 / Math.tan(x);
  },
  arcsec: function(x) {
    return arccos(1 / x);
  },
  arccsc: function(x) {
    return arcsin(1 / x);
  },
  arccot: function(x) {
    return arctan(1 / x);
  }
};

evaluateMath = function(str) {
  var hasComma, i, l, t, tokens, _i, _len;
  hasComma = str.match(/,/);
  str = mathjs(str);
  tokens = str.split(/\b/);
  for (i = _i = 0, _len = tokens.length; _i < _len; i = ++_i) {
    t = tokens[i];
    if (t in MathFunctions) {
      tokens[i] = "MathFunctions." + t;
    }
  }
  str = tokens.join('');
  console.log(str);
  if (hasComma) {
    return (function() {
      var _j, _len1, _ref, _results;
      _ref = str.split(/,/);
      _results = [];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        l = _ref[_j];
        _results.push(eval(l));
      }
      return _results;
    })();
  } else {
    return eval(str);
  }
};

/*
# The math pre-processor from asciiSvg
*/


mathjs = function(st) {
  var ch, i, j, k, nested;
  st = st.replace(/\s/g, "");
  if (st.indexOf("^-1") !== -1) {
    st = st.replace(/sin\^-1/g, "arcsin");
    st = st.replace(/cos\^-1/g, "arccos");
    st = st.replace(/tan\^-1/g, "arctan");
    st = st.replace(/sec\^-1/g, "arcsec");
    st = st.replace(/csc\^-1/g, "arccsc");
    st = st.replace(/cot\^-1/g, "arccot");
    st = st.replace(/sinh\^-1/g, "arcsinh");
    st = st.replace(/cosh\^-1/g, "arccosh");
    st = st.replace(/tanh\^-1/g, "arctanh");
    st = st.replace(/sech\^-1/g, "arcsech");
    st = st.replace(/csch\^-1/g, "arccsch");
    st = st.replace(/coth\^-1/g, "arccoth");
  }
  st = st.replace(/^e$/g, "(E)");
  st = st.replace(/^e([^a-zA-Z])/g, "(E)$1");
  st = st.replace(/([^a-zA-Z])e([^a-zA-Z])/g, "$1(E)$2");
  st = st.replace(/([0-9])([\(a-zA-Z])/g, "$1*$2");
  st = st.replace(/\)([\(0-9a-zA-Z])/g, ")*$1");
  i = void 0;
  j = void 0;
  k = void 0;
  ch = void 0;
  nested = void 0;
  while ((i = st.indexOf("^")) !== -1) {
    if (i === 0) {
      throw new Error("missing argument for '^'");
    }
    j = i - 1;
    ch = st.charAt(j);
    if (ch >= "0" && ch <= "9") {
      j--;
      while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
        j--;
      }
      if (ch === ".") {
        j--;
        while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
          j--;
        }
      }
    } else if (ch === ")") {
      nested = 1;
      j--;
      while (j >= 0 && nested > 0) {
        ch = st.charAt(j);
        if (ch === "(") {
          nested--;
        } else {
          if (ch === ")") {
            nested++;
          }
        }
        j--;
      }
      while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        j--;
      }
    } else if (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
      j--;
      while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        j--;
      }
    } else {
      throw new Error("incorrect syntax in " + st + " at position " + j);
    }
    if (i === st.length - 1) {
      throw new Error("missing argument");
    }
    k = i + 1;
    ch = st.charAt(k);
    if (ch >= "0" && ch <= "9" || ch === "-") {
      k++;
      while (k < st.length && (ch = st.charAt(k)) >= "0" && ch <= "9") {
        k++;
      }
      if (ch === ".") {
        k++;
        while (k < st.length && (ch = st.charAt(k)) >= "0" && ch <= "9") {
          k++;
        }
      }
    } else if (ch === "(") {
      nested = 1;
      k++;
      while (k < st.length && nested > 0) {
        ch = st.charAt(k);
        if (ch === "(") {
          nested++;
        } else {
          if (ch === ")") {
            nested--;
          }
        }
        k++;
      }
    } else if (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
      k++;
      while (k < st.length && (ch = st.charAt(k)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        k++;
      }
    } else {
      throw new Error("incorrect syntax in " + st + " at position " + k);
    }
    st = st.slice(0, j + 1) + "pow(" + st.slice(j + 1, i) + "," + st.slice(i + 1, k) + ")" + st.slice(k);
  }
  while ((i = st.indexOf("!")) !== -1) {
    if (i === 0) {
      throw new Error("missing argument for '!'");
    }
    j = i - 1;
    ch = st.charAt(j);
    if (ch >= "0" && ch <= "9") {
      j--;
      while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
        j--;
      }
      if (ch === ".") {
        j--;
        while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
          j--;
        }
      }
    } else if (ch === ")") {
      nested = 1;
      j--;
      while (j >= 0 && nested > 0) {
        ch = st.charAt(j);
        if (ch === "(") {
          nested--;
        } else {
          if (ch === ")") {
            nested++;
          }
        }
        j--;
      }
      while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        j--;
      }
    } else if (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
      j--;
      while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        j--;
      }
    } else {
      throw new Error("incorrect syntax in " + st + " at position " + j);
    }
    st = st.slice(0, j + 1) + "factorial(" + st.slice(j + 1, i) + ")" + st.slice(i + 1);
  }
  return st;
};
